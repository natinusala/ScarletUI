
/*
   Copyright 2022 natinusala

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// File generated by gen_tupleview.py, do not edit

public struct TupleView2<C0, C1>: View where C0: View, C1: View {
    public typealias Body = Never

    let c0: C0
    let c1: C1

    public static func makeViews(view: Self, previous: Self?) -> [ElementOperation] {
        let c0Operations = C0.makeViews(view: view.c0, previous: previous?.c0)
        let c1Operations = C1.makeViews(view: view.c1, previous: previous?.c1)

        let c0Offset: Int = 0
        let c1Offset: Int

            c1Offset = C0.viewsCount(view: view.c0) + c0Offset

        return c0Operations.appendAndOffset(operations: c1Operations, offset: c1Offset)
    }

    public static func viewsCount(view: Self) -> Int {
        return C0.viewsCount(view: view.c0) + C1.viewsCount(view: view.c1)
    }
}

public extension ViewBuilder {
    static func buildBlock<C0: View, C1: View>(_ c0: C0, _ c1: C1) -> TupleView2<C0, C1> {
        return .init(c0: c0, c1: c1)
    }
}

extension TupleView2: Equatable where C0: Equatable, C1: Equatable {
    public static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.c0 == rhs.c0 else {
            return false
        }
        guard lhs.c1 == rhs.c1 else {
            return false
        }

        return true
    }
}

public struct TupleView3<C0, C1, C2>: View where C0: View, C1: View, C2: View {
    public typealias Body = Never

    let c0: C0
    let c1: C1
    let c2: C2

    public static func makeViews(view: Self, previous: Self?) -> [ElementOperation] {
        let c0Operations = C0.makeViews(view: view.c0, previous: previous?.c0)
        let c1Operations = C1.makeViews(view: view.c1, previous: previous?.c1)
        let c2Operations = C2.makeViews(view: view.c2, previous: previous?.c2)

        let c0Offset: Int = 0
        let c1Offset: Int
        let c2Offset: Int

            c1Offset = C0.viewsCount(view: view.c0) + c0Offset
            c2Offset = C1.viewsCount(view: view.c1) + c1Offset

        return c0Operations.appendAndOffset(operations: c1Operations, offset: c1Offset).appendAndOffset(operations: c2Operations, offset: c2Offset)
    }

    public static func viewsCount(view: Self) -> Int {
        return C0.viewsCount(view: view.c0) + C1.viewsCount(view: view.c1) + C2.viewsCount(view: view.c2)
    }
}

public extension ViewBuilder {
    static func buildBlock<C0: View, C1: View, C2: View>(_ c0: C0, _ c1: C1, _ c2: C2) -> TupleView3<C0, C1, C2> {
        return .init(c0: c0, c1: c1, c2: c2)
    }
}

extension TupleView3: Equatable where C0: Equatable, C1: Equatable, C2: Equatable {
    public static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.c0 == rhs.c0 else {
            return false
        }
        guard lhs.c1 == rhs.c1 else {
            return false
        }
        guard lhs.c2 == rhs.c2 else {
            return false
        }

        return true
    }
}

public struct TupleView4<C0, C1, C2, C3>: View where C0: View, C1: View, C2: View, C3: View {
    public typealias Body = Never

    let c0: C0
    let c1: C1
    let c2: C2
    let c3: C3

    public static func makeViews(view: Self, previous: Self?) -> [ElementOperation] {
        let c0Operations = C0.makeViews(view: view.c0, previous: previous?.c0)
        let c1Operations = C1.makeViews(view: view.c1, previous: previous?.c1)
        let c2Operations = C2.makeViews(view: view.c2, previous: previous?.c2)
        let c3Operations = C3.makeViews(view: view.c3, previous: previous?.c3)

        let c0Offset: Int = 0
        let c1Offset: Int
        let c2Offset: Int
        let c3Offset: Int

            c1Offset = C0.viewsCount(view: view.c0) + c0Offset
            c2Offset = C1.viewsCount(view: view.c1) + c1Offset
            c3Offset = C2.viewsCount(view: view.c2) + c2Offset

        return c0Operations.appendAndOffset(operations: c1Operations, offset: c1Offset).appendAndOffset(operations: c2Operations, offset: c2Offset).appendAndOffset(operations: c3Operations, offset: c3Offset)
    }

    public static func viewsCount(view: Self) -> Int {
        return C0.viewsCount(view: view.c0) + C1.viewsCount(view: view.c1) + C2.viewsCount(view: view.c2) + C3.viewsCount(view: view.c3)
    }
}

public extension ViewBuilder {
    static func buildBlock<C0: View, C1: View, C2: View, C3: View>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> TupleView4<C0, C1, C2, C3> {
        return .init(c0: c0, c1: c1, c2: c2, c3: c3)
    }
}

extension TupleView4: Equatable where C0: Equatable, C1: Equatable, C2: Equatable, C3: Equatable {
    public static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.c0 == rhs.c0 else {
            return false
        }
        guard lhs.c1 == rhs.c1 else {
            return false
        }
        guard lhs.c2 == rhs.c2 else {
            return false
        }
        guard lhs.c3 == rhs.c3 else {
            return false
        }

        return true
    }
}

public struct TupleView5<C0, C1, C2, C3, C4>: View where C0: View, C1: View, C2: View, C3: View, C4: View {
    public typealias Body = Never

    let c0: C0
    let c1: C1
    let c2: C2
    let c3: C3
    let c4: C4

    public static func makeViews(view: Self, previous: Self?) -> [ElementOperation] {
        let c0Operations = C0.makeViews(view: view.c0, previous: previous?.c0)
        let c1Operations = C1.makeViews(view: view.c1, previous: previous?.c1)
        let c2Operations = C2.makeViews(view: view.c2, previous: previous?.c2)
        let c3Operations = C3.makeViews(view: view.c3, previous: previous?.c3)
        let c4Operations = C4.makeViews(view: view.c4, previous: previous?.c4)

        let c0Offset: Int = 0
        let c1Offset: Int
        let c2Offset: Int
        let c3Offset: Int
        let c4Offset: Int

            c1Offset = C0.viewsCount(view: view.c0) + c0Offset
            c2Offset = C1.viewsCount(view: view.c1) + c1Offset
            c3Offset = C2.viewsCount(view: view.c2) + c2Offset
            c4Offset = C3.viewsCount(view: view.c3) + c3Offset

        return c0Operations.appendAndOffset(operations: c1Operations, offset: c1Offset).appendAndOffset(operations: c2Operations, offset: c2Offset).appendAndOffset(operations: c3Operations, offset: c3Offset).appendAndOffset(operations: c4Operations, offset: c4Offset)
    }

    public static func viewsCount(view: Self) -> Int {
        return C0.viewsCount(view: view.c0) + C1.viewsCount(view: view.c1) + C2.viewsCount(view: view.c2) + C3.viewsCount(view: view.c3) + C4.viewsCount(view: view.c4)
    }
}

public extension ViewBuilder {
    static func buildBlock<C0: View, C1: View, C2: View, C3: View, C4: View>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> TupleView5<C0, C1, C2, C3, C4> {
        return .init(c0: c0, c1: c1, c2: c2, c3: c3, c4: c4)
    }
}

extension TupleView5: Equatable where C0: Equatable, C1: Equatable, C2: Equatable, C3: Equatable, C4: Equatable {
    public static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.c0 == rhs.c0 else {
            return false
        }
        guard lhs.c1 == rhs.c1 else {
            return false
        }
        guard lhs.c2 == rhs.c2 else {
            return false
        }
        guard lhs.c3 == rhs.c3 else {
            return false
        }
        guard lhs.c4 == rhs.c4 else {
            return false
        }

        return true
    }
}

public struct TupleView6<C0, C1, C2, C3, C4, C5>: View where C0: View, C1: View, C2: View, C3: View, C4: View, C5: View {
    public typealias Body = Never

    let c0: C0
    let c1: C1
    let c2: C2
    let c3: C3
    let c4: C4
    let c5: C5

    public static func makeViews(view: Self, previous: Self?) -> [ElementOperation] {
        let c0Operations = C0.makeViews(view: view.c0, previous: previous?.c0)
        let c1Operations = C1.makeViews(view: view.c1, previous: previous?.c1)
        let c2Operations = C2.makeViews(view: view.c2, previous: previous?.c2)
        let c3Operations = C3.makeViews(view: view.c3, previous: previous?.c3)
        let c4Operations = C4.makeViews(view: view.c4, previous: previous?.c4)
        let c5Operations = C5.makeViews(view: view.c5, previous: previous?.c5)

        let c0Offset: Int = 0
        let c1Offset: Int
        let c2Offset: Int
        let c3Offset: Int
        let c4Offset: Int
        let c5Offset: Int

            c1Offset = C0.viewsCount(view: view.c0) + c0Offset
            c2Offset = C1.viewsCount(view: view.c1) + c1Offset
            c3Offset = C2.viewsCount(view: view.c2) + c2Offset
            c4Offset = C3.viewsCount(view: view.c3) + c3Offset
            c5Offset = C4.viewsCount(view: view.c4) + c4Offset

        return c0Operations.appendAndOffset(operations: c1Operations, offset: c1Offset).appendAndOffset(operations: c2Operations, offset: c2Offset).appendAndOffset(operations: c3Operations, offset: c3Offset).appendAndOffset(operations: c4Operations, offset: c4Offset).appendAndOffset(operations: c5Operations, offset: c5Offset)
    }

    public static func viewsCount(view: Self) -> Int {
        return C0.viewsCount(view: view.c0) + C1.viewsCount(view: view.c1) + C2.viewsCount(view: view.c2) + C3.viewsCount(view: view.c3) + C4.viewsCount(view: view.c4) + C5.viewsCount(view: view.c5)
    }
}

public extension ViewBuilder {
    static func buildBlock<C0: View, C1: View, C2: View, C3: View, C4: View, C5: View>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> TupleView6<C0, C1, C2, C3, C4, C5> {
        return .init(c0: c0, c1: c1, c2: c2, c3: c3, c4: c4, c5: c5)
    }
}

extension TupleView6: Equatable where C0: Equatable, C1: Equatable, C2: Equatable, C3: Equatable, C4: Equatable, C5: Equatable {
    public static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.c0 == rhs.c0 else {
            return false
        }
        guard lhs.c1 == rhs.c1 else {
            return false
        }
        guard lhs.c2 == rhs.c2 else {
            return false
        }
        guard lhs.c3 == rhs.c3 else {
            return false
        }
        guard lhs.c4 == rhs.c4 else {
            return false
        }
        guard lhs.c5 == rhs.c5 else {
            return false
        }

        return true
    }
}

public struct TupleView7<C0, C1, C2, C3, C4, C5, C6>: View where C0: View, C1: View, C2: View, C3: View, C4: View, C5: View, C6: View {
    public typealias Body = Never

    let c0: C0
    let c1: C1
    let c2: C2
    let c3: C3
    let c4: C4
    let c5: C5
    let c6: C6

    public static func makeViews(view: Self, previous: Self?) -> [ElementOperation] {
        let c0Operations = C0.makeViews(view: view.c0, previous: previous?.c0)
        let c1Operations = C1.makeViews(view: view.c1, previous: previous?.c1)
        let c2Operations = C2.makeViews(view: view.c2, previous: previous?.c2)
        let c3Operations = C3.makeViews(view: view.c3, previous: previous?.c3)
        let c4Operations = C4.makeViews(view: view.c4, previous: previous?.c4)
        let c5Operations = C5.makeViews(view: view.c5, previous: previous?.c5)
        let c6Operations = C6.makeViews(view: view.c6, previous: previous?.c6)

        let c0Offset: Int = 0
        let c1Offset: Int
        let c2Offset: Int
        let c3Offset: Int
        let c4Offset: Int
        let c5Offset: Int
        let c6Offset: Int

            c1Offset = C0.viewsCount(view: view.c0) + c0Offset
            c2Offset = C1.viewsCount(view: view.c1) + c1Offset
            c3Offset = C2.viewsCount(view: view.c2) + c2Offset
            c4Offset = C3.viewsCount(view: view.c3) + c3Offset
            c5Offset = C4.viewsCount(view: view.c4) + c4Offset
            c6Offset = C5.viewsCount(view: view.c5) + c5Offset

        return c0Operations.appendAndOffset(operations: c1Operations, offset: c1Offset).appendAndOffset(operations: c2Operations, offset: c2Offset).appendAndOffset(operations: c3Operations, offset: c3Offset).appendAndOffset(operations: c4Operations, offset: c4Offset).appendAndOffset(operations: c5Operations, offset: c5Offset).appendAndOffset(operations: c6Operations, offset: c6Offset)
    }

    public static func viewsCount(view: Self) -> Int {
        return C0.viewsCount(view: view.c0) + C1.viewsCount(view: view.c1) + C2.viewsCount(view: view.c2) + C3.viewsCount(view: view.c3) + C4.viewsCount(view: view.c4) + C5.viewsCount(view: view.c5) + C6.viewsCount(view: view.c6)
    }
}

public extension ViewBuilder {
    static func buildBlock<C0: View, C1: View, C2: View, C3: View, C4: View, C5: View, C6: View>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> TupleView7<C0, C1, C2, C3, C4, C5, C6> {
        return .init(c0: c0, c1: c1, c2: c2, c3: c3, c4: c4, c5: c5, c6: c6)
    }
}

extension TupleView7: Equatable where C0: Equatable, C1: Equatable, C2: Equatable, C3: Equatable, C4: Equatable, C5: Equatable, C6: Equatable {
    public static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.c0 == rhs.c0 else {
            return false
        }
        guard lhs.c1 == rhs.c1 else {
            return false
        }
        guard lhs.c2 == rhs.c2 else {
            return false
        }
        guard lhs.c3 == rhs.c3 else {
            return false
        }
        guard lhs.c4 == rhs.c4 else {
            return false
        }
        guard lhs.c5 == rhs.c5 else {
            return false
        }
        guard lhs.c6 == rhs.c6 else {
            return false
        }

        return true
    }
}

public struct TupleView8<C0, C1, C2, C3, C4, C5, C6, C7>: View where C0: View, C1: View, C2: View, C3: View, C4: View, C5: View, C6: View, C7: View {
    public typealias Body = Never

    let c0: C0
    let c1: C1
    let c2: C2
    let c3: C3
    let c4: C4
    let c5: C5
    let c6: C6
    let c7: C7

    public static func makeViews(view: Self, previous: Self?) -> [ElementOperation] {
        let c0Operations = C0.makeViews(view: view.c0, previous: previous?.c0)
        let c1Operations = C1.makeViews(view: view.c1, previous: previous?.c1)
        let c2Operations = C2.makeViews(view: view.c2, previous: previous?.c2)
        let c3Operations = C3.makeViews(view: view.c3, previous: previous?.c3)
        let c4Operations = C4.makeViews(view: view.c4, previous: previous?.c4)
        let c5Operations = C5.makeViews(view: view.c5, previous: previous?.c5)
        let c6Operations = C6.makeViews(view: view.c6, previous: previous?.c6)
        let c7Operations = C7.makeViews(view: view.c7, previous: previous?.c7)

        let c0Offset: Int = 0
        let c1Offset: Int
        let c2Offset: Int
        let c3Offset: Int
        let c4Offset: Int
        let c5Offset: Int
        let c6Offset: Int
        let c7Offset: Int

            c1Offset = C0.viewsCount(view: view.c0) + c0Offset
            c2Offset = C1.viewsCount(view: view.c1) + c1Offset
            c3Offset = C2.viewsCount(view: view.c2) + c2Offset
            c4Offset = C3.viewsCount(view: view.c3) + c3Offset
            c5Offset = C4.viewsCount(view: view.c4) + c4Offset
            c6Offset = C5.viewsCount(view: view.c5) + c5Offset
            c7Offset = C6.viewsCount(view: view.c6) + c6Offset

        return c0Operations.appendAndOffset(operations: c1Operations, offset: c1Offset).appendAndOffset(operations: c2Operations, offset: c2Offset).appendAndOffset(operations: c3Operations, offset: c3Offset).appendAndOffset(operations: c4Operations, offset: c4Offset).appendAndOffset(operations: c5Operations, offset: c5Offset).appendAndOffset(operations: c6Operations, offset: c6Offset).appendAndOffset(operations: c7Operations, offset: c7Offset)
    }

    public static func viewsCount(view: Self) -> Int {
        return C0.viewsCount(view: view.c0) + C1.viewsCount(view: view.c1) + C2.viewsCount(view: view.c2) + C3.viewsCount(view: view.c3) + C4.viewsCount(view: view.c4) + C5.viewsCount(view: view.c5) + C6.viewsCount(view: view.c6) + C7.viewsCount(view: view.c7)
    }
}

public extension ViewBuilder {
    static func buildBlock<C0: View, C1: View, C2: View, C3: View, C4: View, C5: View, C6: View, C7: View>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> TupleView8<C0, C1, C2, C3, C4, C5, C6, C7> {
        return .init(c0: c0, c1: c1, c2: c2, c3: c3, c4: c4, c5: c5, c6: c6, c7: c7)
    }
}

extension TupleView8: Equatable where C0: Equatable, C1: Equatable, C2: Equatable, C3: Equatable, C4: Equatable, C5: Equatable, C6: Equatable, C7: Equatable {
    public static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.c0 == rhs.c0 else {
            return false
        }
        guard lhs.c1 == rhs.c1 else {
            return false
        }
        guard lhs.c2 == rhs.c2 else {
            return false
        }
        guard lhs.c3 == rhs.c3 else {
            return false
        }
        guard lhs.c4 == rhs.c4 else {
            return false
        }
        guard lhs.c5 == rhs.c5 else {
            return false
        }
        guard lhs.c6 == rhs.c6 else {
            return false
        }
        guard lhs.c7 == rhs.c7 else {
            return false
        }

        return true
    }
}

public struct TupleView9<C0, C1, C2, C3, C4, C5, C6, C7, C8>: View where C0: View, C1: View, C2: View, C3: View, C4: View, C5: View, C6: View, C7: View, C8: View {
    public typealias Body = Never

    let c0: C0
    let c1: C1
    let c2: C2
    let c3: C3
    let c4: C4
    let c5: C5
    let c6: C6
    let c7: C7
    let c8: C8

    public static func makeViews(view: Self, previous: Self?) -> [ElementOperation] {
        let c0Operations = C0.makeViews(view: view.c0, previous: previous?.c0)
        let c1Operations = C1.makeViews(view: view.c1, previous: previous?.c1)
        let c2Operations = C2.makeViews(view: view.c2, previous: previous?.c2)
        let c3Operations = C3.makeViews(view: view.c3, previous: previous?.c3)
        let c4Operations = C4.makeViews(view: view.c4, previous: previous?.c4)
        let c5Operations = C5.makeViews(view: view.c5, previous: previous?.c5)
        let c6Operations = C6.makeViews(view: view.c6, previous: previous?.c6)
        let c7Operations = C7.makeViews(view: view.c7, previous: previous?.c7)
        let c8Operations = C8.makeViews(view: view.c8, previous: previous?.c8)

        let c0Offset: Int = 0
        let c1Offset: Int
        let c2Offset: Int
        let c3Offset: Int
        let c4Offset: Int
        let c5Offset: Int
        let c6Offset: Int
        let c7Offset: Int
        let c8Offset: Int

            c1Offset = C0.viewsCount(view: view.c0) + c0Offset
            c2Offset = C1.viewsCount(view: view.c1) + c1Offset
            c3Offset = C2.viewsCount(view: view.c2) + c2Offset
            c4Offset = C3.viewsCount(view: view.c3) + c3Offset
            c5Offset = C4.viewsCount(view: view.c4) + c4Offset
            c6Offset = C5.viewsCount(view: view.c5) + c5Offset
            c7Offset = C6.viewsCount(view: view.c6) + c6Offset
            c8Offset = C7.viewsCount(view: view.c7) + c7Offset

        return c0Operations.appendAndOffset(operations: c1Operations, offset: c1Offset).appendAndOffset(operations: c2Operations, offset: c2Offset).appendAndOffset(operations: c3Operations, offset: c3Offset).appendAndOffset(operations: c4Operations, offset: c4Offset).appendAndOffset(operations: c5Operations, offset: c5Offset).appendAndOffset(operations: c6Operations, offset: c6Offset).appendAndOffset(operations: c7Operations, offset: c7Offset).appendAndOffset(operations: c8Operations, offset: c8Offset)
    }

    public static func viewsCount(view: Self) -> Int {
        return C0.viewsCount(view: view.c0) + C1.viewsCount(view: view.c1) + C2.viewsCount(view: view.c2) + C3.viewsCount(view: view.c3) + C4.viewsCount(view: view.c4) + C5.viewsCount(view: view.c5) + C6.viewsCount(view: view.c6) + C7.viewsCount(view: view.c7) + C8.viewsCount(view: view.c8)
    }
}

public extension ViewBuilder {
    static func buildBlock<C0: View, C1: View, C2: View, C3: View, C4: View, C5: View, C6: View, C7: View, C8: View>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> TupleView9<C0, C1, C2, C3, C4, C5, C6, C7, C8> {
        return .init(c0: c0, c1: c1, c2: c2, c3: c3, c4: c4, c5: c5, c6: c6, c7: c7, c8: c8)
    }
}

extension TupleView9: Equatable where C0: Equatable, C1: Equatable, C2: Equatable, C3: Equatable, C4: Equatable, C5: Equatable, C6: Equatable, C7: Equatable, C8: Equatable {
    public static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.c0 == rhs.c0 else {
            return false
        }
        guard lhs.c1 == rhs.c1 else {
            return false
        }
        guard lhs.c2 == rhs.c2 else {
            return false
        }
        guard lhs.c3 == rhs.c3 else {
            return false
        }
        guard lhs.c4 == rhs.c4 else {
            return false
        }
        guard lhs.c5 == rhs.c5 else {
            return false
        }
        guard lhs.c6 == rhs.c6 else {
            return false
        }
        guard lhs.c7 == rhs.c7 else {
            return false
        }
        guard lhs.c8 == rhs.c8 else {
            return false
        }

        return true
    }
}

public struct TupleView10<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>: View where C0: View, C1: View, C2: View, C3: View, C4: View, C5: View, C6: View, C7: View, C8: View, C9: View {
    public typealias Body = Never

    let c0: C0
    let c1: C1
    let c2: C2
    let c3: C3
    let c4: C4
    let c5: C5
    let c6: C6
    let c7: C7
    let c8: C8
    let c9: C9

    public static func makeViews(view: Self, previous: Self?) -> [ElementOperation] {
        let c0Operations = C0.makeViews(view: view.c0, previous: previous?.c0)
        let c1Operations = C1.makeViews(view: view.c1, previous: previous?.c1)
        let c2Operations = C2.makeViews(view: view.c2, previous: previous?.c2)
        let c3Operations = C3.makeViews(view: view.c3, previous: previous?.c3)
        let c4Operations = C4.makeViews(view: view.c4, previous: previous?.c4)
        let c5Operations = C5.makeViews(view: view.c5, previous: previous?.c5)
        let c6Operations = C6.makeViews(view: view.c6, previous: previous?.c6)
        let c7Operations = C7.makeViews(view: view.c7, previous: previous?.c7)
        let c8Operations = C8.makeViews(view: view.c8, previous: previous?.c8)
        let c9Operations = C9.makeViews(view: view.c9, previous: previous?.c9)

        let c0Offset: Int = 0
        let c1Offset: Int
        let c2Offset: Int
        let c3Offset: Int
        let c4Offset: Int
        let c5Offset: Int
        let c6Offset: Int
        let c7Offset: Int
        let c8Offset: Int
        let c9Offset: Int

            c1Offset = C0.viewsCount(view: view.c0) + c0Offset
            c2Offset = C1.viewsCount(view: view.c1) + c1Offset
            c3Offset = C2.viewsCount(view: view.c2) + c2Offset
            c4Offset = C3.viewsCount(view: view.c3) + c3Offset
            c5Offset = C4.viewsCount(view: view.c4) + c4Offset
            c6Offset = C5.viewsCount(view: view.c5) + c5Offset
            c7Offset = C6.viewsCount(view: view.c6) + c6Offset
            c8Offset = C7.viewsCount(view: view.c7) + c7Offset
            c9Offset = C8.viewsCount(view: view.c8) + c8Offset

        return c0Operations.appendAndOffset(operations: c1Operations, offset: c1Offset).appendAndOffset(operations: c2Operations, offset: c2Offset).appendAndOffset(operations: c3Operations, offset: c3Offset).appendAndOffset(operations: c4Operations, offset: c4Offset).appendAndOffset(operations: c5Operations, offset: c5Offset).appendAndOffset(operations: c6Operations, offset: c6Offset).appendAndOffset(operations: c7Operations, offset: c7Offset).appendAndOffset(operations: c8Operations, offset: c8Offset).appendAndOffset(operations: c9Operations, offset: c9Offset)
    }

    public static func viewsCount(view: Self) -> Int {
        return C0.viewsCount(view: view.c0) + C1.viewsCount(view: view.c1) + C2.viewsCount(view: view.c2) + C3.viewsCount(view: view.c3) + C4.viewsCount(view: view.c4) + C5.viewsCount(view: view.c5) + C6.viewsCount(view: view.c6) + C7.viewsCount(view: view.c7) + C8.viewsCount(view: view.c8) + C9.viewsCount(view: view.c9)
    }
}

public extension ViewBuilder {
    static func buildBlock<C0: View, C1: View, C2: View, C3: View, C4: View, C5: View, C6: View, C7: View, C8: View, C9: View>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> TupleView10<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9> {
        return .init(c0: c0, c1: c1, c2: c2, c3: c3, c4: c4, c5: c5, c6: c6, c7: c7, c8: c8, c9: c9)
    }
}

extension TupleView10: Equatable where C0: Equatable, C1: Equatable, C2: Equatable, C3: Equatable, C4: Equatable, C5: Equatable, C6: Equatable, C7: Equatable, C8: Equatable, C9: Equatable {
    public static func == (lhs: Self, rhs: Self) -> Bool {
        guard lhs.c0 == rhs.c0 else {
            return false
        }
        guard lhs.c1 == rhs.c1 else {
            return false
        }
        guard lhs.c2 == rhs.c2 else {
            return false
        }
        guard lhs.c3 == rhs.c3 else {
            return false
        }
        guard lhs.c4 == rhs.c4 else {
            return false
        }
        guard lhs.c5 == rhs.c5 else {
            return false
        }
        guard lhs.c6 == rhs.c6 else {
            return false
        }
        guard lhs.c7 == rhs.c7 else {
            return false
        }
        guard lhs.c8 == rhs.c8 else {
            return false
        }
        guard lhs.c9 == rhs.c9 else {
            return false
        }

        return true
    }
}
